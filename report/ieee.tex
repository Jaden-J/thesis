\documentclass[conference]{IEEEtran}
\usepackage[pdftex]{graphicx}
\usepackage[cmex10]{amsmath}
\interdisplaylinepenalty=2500
\usepackage{algorithmic}
\usepackage{array}
\usepackage{mdwmath}
\usepackage{mdwtab}
\usepackage{eqparbox}
\usepackage[font=footnotesize]{subfig}
\usepackage{fixltx2e}
\usepackage{url}
\hyphenation{op-tical net-works semi-conduc-tor}

% additional packages and utility commands
\usepackage{minted}

\usepackage{lineno}
\setlength\linenumbersep{1mm}
\linenumbers

\begin{document}

% to avoid syntax error highlighting - e.g. foo's not js ;-)
\expandafter\def\csname PY@tok@err\endcsname{}

\title{Lowering the Impact of Intrusion Detection\\
on Resources in Wireless Sensor Networks\\
using a Domain Specific Language\\
and Code Generation Techniques}

\author{\IEEEauthorblockN{Christophe Van Ginneken, Jef Maerien, Christophe
Huygens, Danny Hughes, Wouter Joosen}%
\IEEEauthorblockA{iMinds - DistriNet - KULeuven\\
B-3001, Leuven, Belgium\\
Christophe.VanGinneken@student.kuleuven.be,\{firstname.lastname\}@cs.kuleuven.be}}

\maketitle

\begin{abstract}
  
Introducing intrusion detection in wireless sensor networks proofs to be a
battle for resources. Implementing and optimizing a collection of detection
algorithms to match the available resources without increasing the production
costs beyond proportion, might very well be an unacceptable economic burden.
This paper introduces a domain specific language to formally describe such
algorithms and proposes the use of code generation techniques to automate the
production of detection software. This automated process allows for the
optimization of resource usage, more specifically the optimization of the
execution of algorithms and the use of the energy-costly wireless radio. A
prototype code generator was constructed to show that these techniques can be
implemented effectively, combining different intrusion detection algorithms in
such way that they impose less impact on the resources than the sum of the
impact of each algorithm by itself.

\end{abstract}

\section{Introduction}

A Wireless sensor network (WSN) is constructed using large numbers of
autonomous embedded devices, called nodes or motes, referring to their
dust-like scale. Their autonomy is rather absolute, being most of the time
battery-powered and deployed in open terrain. Examples of WSNs include
monitoring systems in volcanic regions or flood areas. Preliminary successes
have now even steered researchers towards the introduction of WSNs in cities
and homes, thus creating smart cities \cite{schaffers2011smart} and smart homes
\cite{chan2008review}.

Due to their involvement in more and more personal applications, securing these
nodes should be a priority. When we entrust these autonomous systems with some
of our most intimate information, for example regarding our health
\cite{stankovic2005wireless}, we would of course like them to be able to
protect this information.

Securing WSNs, and especially single nodes, is a daunting task
\cite{perrig2004security}. Mostly due to their autonomous nature, nodes are
most of the time physically accessible. With physical access comes a wide range
of physical attacks \cite{becher2006tampering} that are hard to detect, let
alone prevent. Even if the nodes aren't physically accessible, their ways of
communicating with the outside world through various forms of wireless
communication, offer a plethora of possibilities \cite{padmavathi2009survey} to
attack them; ranging from low-level meddling with the routing of packets in the
network, up to the application level.

Securing nodes against intrusions should be a primary objective. But often this
turns out to be impossible and intrusions are sometimes only noticed
post-mortem. When prevention is not guaranteed, a second line of defence
consists in the detection of intrusions, allowing reactive systems to be
introduced to prevent future problematic situations. These intrusion detection
systems (IDS) are well-known in classic networked environments, but are not
easily transferred to the world of WSNs \cite{zhang2000intrusion}
\cite{djenouri2005survey}, mostly due to the wireless and ad-hoc nature of the
networks and the lack of a central point where communication can be monitored.

But WSNs bring even another problem to the table: resources. Due to their
vastly deployed numbers and policy to be replaced rather than salvaged, nodes
typically need to be cheap. Their limited functional requirements allow for
them to be built using simple components without redundancy or excess margins.
This introduces an inherent problem for IDS. These systems not only typically
require a lot of resources to store detection information and have to execute
their algorithms over and over again, but also want to inspect every single
network packet that's passing by. This way they not only would like the node to
be powered-on all the time, they also need constant access to the wireless
radio, which turns out to be the number one energy-consumer of a node.
Introducing IDS in a WSN turns out to be a battle for resources.

Finally, besides the technical resources, there is also an economic resource
that plays an important part here. Given the same limited functionality, adding
a complex piece like an IDS, might very well raise the production cost well
above acceptable levels. The fact that IDS algorithms are currently in a mere
state of research, would currently require a developer to read through many
research papers, making a selection of algorithms and implement them from
scratch. Even if implementations for each of these algorithms would be
available, the chance that they are applicable to the target platform is
another big if. Integrating these algorithms is in itself already a complex
matter.

Our contribution to IDS in WSNs is the introduction of a domain specific
language (DSL) to formally describe IDS algorithms. The DSL is node-oriented
with a strong focus on inter-node communication and aims to allow for the
optimisation of execution of multiple IDS algorithms, thus lowering the
sequential and iterative execution of algorithms and optimizing the use of the
wireless radio.

Introducing such a formal, platform-independent language to express IDS
algorithms and accompanying this language with a code generation framework,
offers an end-to-end solution to many of the problems introduced above.
Research output would be directly applicable in a development environment and a
code generation framework allows developers to simply select algorithms and
have platform-specific code without any effort. Due to the possibility to
optimize the use of resources, the impact of introducing an IDS can be lowered
allowing more algorithms to be added, thus augmenting the barriers for
intruders, which can help to reduce the number of undetected intrusions.

The remainder of this paper proceeds as follows: section \ref{section:related}
introduces the field of IDS in WSNs by means of several IDS algorithms from
research papers. Section \ref{section:problem} describes the problem space in
detail, covering the different parties involved and their contributions.
Section \ref{section:solution} introduces our proposed overall solution, which
is further detailed in sections \ref{section:foo-lang} and
\ref{section:prototype}, which respectively present our domain specific
language, FOO-lang, focusing on the optimization of the organization of
functionality, as well as a prototype implementation of a code generator
framework to complement the language. Section \ref{section:evaluation}
evaluates the prototype implementation and determines if the theoretical merits
of introducing FOO-lang, are actually viable. Finally, section
\ref{section:conclusions} presents our conclusions and proposes topics for
future research to fine-tune the initial findings.

\section{Related Work}
\label{section:related}

Securing any network initially tries to prevent intrusions from happening. This
should of course be a primary concern. But not all intrusions can be prevented
and we need to fall back to detecting intrusions. In this section we take a
look at recent contributions in this field.

Intrusions, or attacks, on computer networks can take many forms. In the case
of WSNs this classification needs to be extended even further. In
\cite{padmavathi2009survey} a good overview of both is presented, showing
clearly that WSNs suffer from their wireless-communication and broadcast nature.
This causes many attacks based on e.g. eavesdropping to be nearly impossible to
detect while they are happening. Only when the actual intrusions, based on
collected information, have happened, the intrusion could possibly be detected
given the after-effects. This means that we can't cover the entire spectrum and
need to focus on what is feasible.

Research into IDS in WSNs typically focuses on two major topics that complement
the architecture of WSNs: the nodes as single entities and the network as a
group of such nodes. Both are important because the group cannot decide without
members that detect malicious behavior and a group-based decision is often
needed because nodes can easily miss out on certain events that could indicate
intrusions, due to their wireless and not-always-on nature.

\subsection{Detecting Intrusions}
\label{subsection:detecting}

There are different ways to construct a taxonomy for intrusion detection, but
common themes do appear. According to \cite{mishra2004intrusion} and
\cite{ioannis2007towards} there are three major categories: anomaly detection,
signature or misuse detection, and specification-based detection. In
\cite{alrajeh2013intrusion} the authors agree mostly with this topology, but
add the notion of hybrid intrusion detection systems and cross layer intrusion
detection systems as recent advances in research. Although these additional
categories offer very interesting prospects, the authors have to admit that the
impact on the resource-constrained sensor nodes might still be too high.

The meshed network topology of WSNs and its routing protocols has produced many
related attacks and each of these attacks has been the focus of many research
papers presenting algorithms to detect them. In the following paragraphs we
take a look at some of the popular ones.

In a wormhole attack, an artificial low-latency link is created between two
distant nodes in the network. This causes the routing protocol to divert more
traffic through this link, offering the attacker with an abundance of packets
to inspect. In \cite{maheshwari2007detecting} an algorithm is proposed to allow
nodes to determine if a wormhole is actively present. In essence, the algorithm
resides on the exchange of neighbour lists to allow nodes to determine if
unexpected substructures are present in the graph representing the network.

Another attack that is related to the wormhole is the sinkhole. When launching
a sinkhole attack, as described in \cite{krontiris2008launching}, the attacker
first needs to compromise an existing node. Being in control of the node, the
attacker can make his captured node look more \emph{attractive} to the
surrounding nodes and thus draw more traffic to itself. The sinkhole attack is
typically a foundation for other routing level attacks, such as selective
forwarding, modification of packets or even dropping them altogether. In its
simplest form, the sinkhole offers the attacker with lots of packets to analyze
and use to gather information about the network and its functionality.

Detecting sinkholes is very hard and often is only possible based on other
attacks that are supported by the sinkhole. When the sinkhole is used to
implement selective forwarding, \cite{ngai2006intruder} proposes an algorithm
that allows a base station, the aggregating master node where all nodes
typically send their information to, to observe missing data from nodes in the
same area in a statistical way.

More typical attacks such as flooding, the sybil attack, rushing,\dots are
amongst others presented in \cite{wood2002denial} and \cite{djenouri2005survey}.

\subsection{Cooperative Decision Making}
\label{subsection:coorperative}

As in many other situations, a group is often stronger that the sum of its
individual components. This is surely the case for WSNs. Because not all nodes
are always actively participating in the network, some nodes might miss queues
that would otherwise lead them to detect intrusions. It is hardly impossible
for a single node to detect a complex attack by itself. Therefore a second
important research topic consists of cooperative algorithms used to combine
information from single nodes into a group-based decision about alleged
intrusions and intruders.

In \cite{krontiris2009cooperative}, the authors first present a theoretical
foundation to analyze cooperative algorithms. Given these foundations they
continue to present an algorithm consisting of 5 phases. It essentially
implements a voting system to identify an intruder based on the Guy Fawkes
protocol \cite{anderson1998new} to exchange suspected intruder information and
allow distributed authentication of those so-called votes. Based on these
authenticated votes, a distributed decision can be made about the commonly
identified intruder.

A distributed, cooperative algorithm can sometimes be implemented locally. This
is illustrated by the reputation-based detection algorithm introduced in
\cite{ganeriwal2008reputation}. Using this algorithm, nodes can exchange
information about the reputation of other nodes. Combining this information
allows them to decide about their trust in a given node, based on more than
only their own often partial observations.

\subsection{Software Attestation}
\label{subsection:attestation}

A research topic that lives parallel to the detection/cooperation duality is
that of software attestation. Software attestation basically tries to offer
algorithms for exchanging information about the software that is running on a
node, and aims to identify nodes that can no longer prove that their content is
unaltered. Examples of evolving algorithms to implement this functionality
include SWATT \cite{seshadri2004swatt}, ICE/SCUBA \cite{seshadri2006scuba} and
SAKE \cite{seshadri2008sake}. The list of authors shows that this topic lives
strong in certain research groups.

Software attestation is hard and many details can cause an algorithm to fail.
Interesting is the discussion surrounding this topic that was started by
\cite{castelluccia2009difficulty}, in response to the previously mentioned
papers. In \cite{perrig2010refutation} the authors of the original papers
counter many of the objections made to their work, but the general feeling is
that even in the best conditions, there is always a way to circumvent even the
most ingenious algorithm to perform software-based attestation.

\section{Problem Analysis}
\label{section:problem}

The problem of introducing IDS in WSNs is much broader than simply the
implementation of a software component. It starts at the very foundations of a
WSNs. In contrast with for example SNORT \cite{roesch1999snort}, there is
currently no community based collection of algorithms that can be implemented.
The reason is mostly due to the lack of a central/external location where all
network traffic can be analyzed out-of-band. In a WSN it's not possible to
create a single entity that will monitor the entire WSN as is the case in a
classic wired network. Therefore, all algorithms typically evolve
independently, without any cohesion.

Even more, all of these algorithms lack a common, formal notation. In the case
of SNORT, a detection language is provided and new signatures are added on a
regular basis, creating an ever growing rule base, capable of detecting even
the newest attacks out there.

If implementers of a WSN want to add IDS to their network, and therefore to the
nodes in the network, they are facing no small task: first they need to collect
research papers, from which they need to extract the proposed algorithms. Even
if the papers would come with an implementation of their algorithm, the chance
that the implementation matches the target platform of the newly created WSN is
slim.

Simply implementing the different algorithms in sequence, or reusing existing
implementations if they would be available, is also no valid option. All of
these algorithms typically perform the same actions: first they analyze each
incoming packet and collect information about nodes, and secondly at given
intervals, they iterate over all known nodes, checking the aggregated
information about them and making decisions about the trust to put in them.
While performing all of these tasks, the algorithms typically also exchange
information with other nodes to complement their own findings.

If such algorithms would simply be combined in a sequential way, the resulting
code would be far from optimal and would consume many of the resources of the
node it runs on: the repetitive parsing of the received packets would result in
much longer processing times than needed, while the chattiness of the
inter-node communication would cause the wireless radio to be on more often
than wanted.

The cost to implement multiple algorithms over and over again, due to the need
to optimize the code's organisation, would soon outweigh the available budget
of any WSN implementation project. If not, the risk to make mistakes in the
often complex algorithms or the lack of flexibility to change sets of detection
algorithms on a regular basis, or simply add a new algorithm in an easy way,
are all very valid reasons to not go down this road. But we still need to be
able to add some form of IDS to WSNs.

\section{Proposed Solution}
\label{section:solution}

Different approaches are possible to address the problems identified above. A
major contribution would consist in the creation of a software framework that
accommodates some of the typical usage patterns: a generic payload parser could
be envisaged, allowing algorithms to hook in using callbacks, thus making sure
that the parsing is only done once and not repeated for each algorithm.
Secondly, the framework could collect all outgoing messages and combine them in
a single outgoing packet at the end of a cycle of the node's event loop.

Such a framework comes with guidelines on how to use it, but still relies on
the good behaviour of its users. Also, the integration of the algorithms with
this framework would still be manual work and reconfiguration would typically
impact this part of the implementation. Finally, although such a framework does
support the implementation, it still requires thorough analysis of research
material and extraction of the relevant algorithms.

In the case of SNORT \cite{roesch1999snort}, or any other classic network IDS
for that matter, the central detection engine accepts formal descriptions of
signatures of attack patterns. Because it isn't possible to create such a
central component once, there has been no urge to describe detection algorithms
in a formal way. By introducing code generation techniques to convert a formal,
platform-independent description of detection algorithms, and generating this
central component, we can bridge the remaining gap.

Code generation allows for the creation of code that implements the actual
algorithm. The algorithm can be described in a platform-independent way,
therefore allowing reuse of the algorithm on multiple platforms. The generated
code can further access a minimal software framework that covers common tasks
and/or platform specific functionality.

Given formal descriptions of the algorithms, an implementer of a new WSN could
simply select a set of algorithms, feed their formal description to the code
generator and obtain platform-specific code, optimized for execution and
communication.

A formal description of detection algorithms would not only be beneficiary to
implementers. Also to researchers such medium would offer substantial benefits.
Formal descriptions of the algorithms not only allows for generation of code,
but the same descriptions can be loaded into simulators and be investigated in
combination with other algorithms \cite{mernik2005and}. Another interesting
option would be that of formal analysis of the algorithms. Further, describing
the algorithms in a platform-independent way, would increase their usefulness
and allow for more complex algorithms to be abstracted.

\section{Introducing FOO-lang}
\label{section:foo-lang}

The central component of our proposed solution is a formal description of
intrusion detection algorithms. This formal description can be realized using a
domain specific language (DSL). Before actually introducing a new language, it
is important to ensure that the reasons to do so are legit. Too often languages
are implemented too quickly, where coding conventions or frameworks with well
thought-out APIs fit the bill quite nicely.

The line can not be drawn in a black and white fashion and DSL do have
benefits, but don't come for free \cite{mernik2005and}. Many good reasons why
to implement a DSL, or not, can be found in \cite{mernik2005and},
\cite{van2000domain} and \cite{fowler2010domain}. Based on these, we try to
justify our choice to propose a DSL for this solution.

\subsection{Justification of the Use of a DSL}
\label{subsection:justification}

The primary goal for the proposed solution is to avoid the creation of
inefficient code that drains the limited resources of a node. Two basic
examples are presented to illustrate this unwanted behaviour: repetitive
execution of the same tasks, such as parsing or iterating a set of known nodes
and the use of the wireless radio.

The latter can be covered by a framework, as illustrated before. It comes with
an obligation to actually use the framework. The former is a bit trickier.
Imagine using the C language as a lingua franca to complement the framework,
that hides the platform specific parts. This could be valid, but offering a
complete language would soon result in loops that break with the guidelines and
would undermine the conceptual idea of optimizing the organisation of the
functionality.

Restricting the formal description to a subset that doesn't allow for
constructions that violate the goals, is in this case a valid reason to tend
towards a DSL. Introducing a DSL further also allows for more functional ways
of handling the concepts that are part of the domain. In this case the domain
clearly consists of interactions between nodes and local processing of
algorithms that typically deal with sets of nodes. Although that C comes close
to a lingua franca amongst both researchers and implementers, it is still a
low-level language with very little support for concise operations such as
pattern matching, event-driven-ness,\dots.

If C doesn't fit the profile, maybe another language does. During the early
days of our research, we looked at a language that seemed to fit the required
functionality like a glove: Erlang \cite{armstrong1993concurrent}. It comes
with strong communication paradigms, has pattern matching, is concurrent and
event-driven by nature,\dots and according to \cite{wong1998compiling} it can
even be translated to C. This road looked very promising, but as with any other
general purpose language, it proved to be too expressive and would allow for
constructions that would thwart the envisaged optimizations.

Our final conclusion is that a real domain-functionality inspired DSL, that
permits researchers to express the detection algorithms without overhead and
without risk of introducing ill behaviour, is the way to move forward.

\subsection{Design Principles for FOO-lang}
\label{subsection:design}

Designing a language is an exciting task, but at the same time comes with great
responsibility. To paraphrase Albert Einstein: it is important to make the
language ``as simple as possible, but not simpler''. The language should come
with enough support to write concise code, but not become obfuscated. The
language constructs it offers should be applicable in generic combinations with
each other and be especially transparent in use. On the other hand, it is also
important that the language restricts the user without limiting his
expressiveness or making certain expressions unintuitive.

Starting from this last requirement, one of the most important things that
should not be available is \emph{loops}. If we want to control the way lists of
data are handled, we need control over the loops targeting that data. In case
of this specific domain, data is centralized around \emph{nodes}, so loops are
typically targeting \emph{nodes}. To meet this restriction but still offer the
user a way to functionally handle nodes, scheduling and events are
introduced. Instead of explicitly constructing a loop, functionality can be
scheduled or attached to certain events that happen on the collection of nodes.
This way, the intended loop is actually abstracted to its functional meaning
and can be handled and combined with other execution strategies.

This is the actual core of the language and it is also where its named derived
from: Function Organization Optimization.

A second important feature of the language is that it should feel natural.
Luckily, dealing with embedded systems and WSNs, both researchers and
implementers share a common language. Most development on these systems is done
using C, and both parties know this language well. We therefore chose to mimic
C for a lot of the general syntax.

FOO-lang also borrows basic syntax from object-oriented (OO) languages, in that
respect that it bears the concept of methods that can be called upon
\emph{objects}. The language doesn't provide any means to define or instantiate
objects though. The \emph{nodes} domain controls the availability of these
objects, creating them and providing them to the functions that are defined.

To avoid typical constructions that require loops, the concept of pattern
matching is introduced. Here a pattern of non-variables and variables can be
provided to functions that support them. If such a function can match the
non-variable part of the pattern, the variables in the pattern take on the
corresponding values of the data against which the match was performed. It is
obvious that this will typically be used to analyze incoming data when
communicating between nodes. Often used in conjunction with this functionality
are list literals, that allow to combine different (non-)variables. So these
are also available in FOO-lang.

To allow complex code to be introduced, FOO-lang provides a way to import
external functionality. This feature is provided through an statement that
allows to define the prototype of the imported function, which can then be used
as any other function.

One final important feature is type inference. FOO-lang tries to limit the need
for typing information. Based on declaration and usage, most types can be
inferred. In doing so, the language tries to focus on the functionality and not
on the technical implementation. This mainly targets the researchers that now
can focus on the bare essence of their algorithms. Also, typing can be
platform-dependent and we want the descriptions to be platform-independent.

\subsection{The Actual Language}
\label{subsection:language}

In the previous paragraphs the design principles of FOO-lang were introduced.
In this section we briefly introduce some of the syntax of FOO-lang using an
example implementation.

Based on the algorithms that were introduced in many of the consulted papers, a
common structure for these algorithms can be detected: (1) when new data is
received the algorithm wants to process it, (2) at regular intervals the
algorithm wants to validate the aggregated information on nodes and (3) the
algorithm might want to communicate with other nodes to exchange information.
Given this structure, we now introduce the \emph{hello world} example for
FOO-lang: \emph{heartbeat}.

It can be considered the most elementary IDS algorithm possible, still
containing all aspects of a generic algorithm. It deals with availability: as
long as we receive regular updates from a node, we trust it. When it fails to
produce a \emph{heartbeat}, we no longer trust it. The resulting FOO-lang code
is presented in listing \ref{lst:heartbeat}.

\inputminted[linenos,xleftmargin=2mm,numbersep=1mm,frame=lines,framesep=2mm,fontsize=\footnotesize,fontfamily=courier]{js}
  {heartbeat.foo}
\captionof{listing}{Example implementation of \emph{heartbeat}.\label{lst:heartbeat}}

Following the design principles, most of this example code should be easy to
understand. FOO-lang tries to be ``readable'', especially to users with a C
background and common knowledge about other languages and programming
paradigms. Most language constructs are borrowed from other languages, like
annotations using the `@' symbol or atoms with the `\#' prefix.

\section{Prototype Code Generator}
\label{section:prototype}

Defining a language is one thing. It should of course also be possible to
generate code from it that actually addresses the problems we identified
before. In case of a language, the real proof is in building an actual code
generator.

We have build a prototype code generator for FOO-lang using Python and ANTLR
\cite{antlr3}. The implementation tries to be as generic as possible and is
based on transformations of abstract syntax trees (AST) and a semantic model
\cite{fowler2010domain}.

The FOO-lang code is parsed using a parser generated by the ANTLR tool. This
produces an AST, which in its turn is transformed into a semantic model using a
visitor. The semantic model represents that actual meaning of the
implementation. From a project point of view, the DSL is merely a textual
representation of the semantic model and the parser and first visitor allow us
to easily populate the model.

The initial model is an exact representation of the FOO-lang code that was
parsed. This means for example that not all types are well defined. A second
visitor, now targeting the semantic model, is used to check all types and try
to infer those that are still marked \emph{unknown}.

With all types known, the model is semantically complete and we can move to the
next phase: construction of a code model. A code model can actually be
considered an AST that can be persisted as code again. The initial code model
that is constructed from the semantic model typically contains all the language
features available in FOO-lang. The construction is done partly by the generic
generator and partly by the \emph{nodes} domain.

The code generator aims to be language and platform independent. Both language
and platform are exchangeable plug-ins to the generator. With the initial code
model based on the full set of language constructs of FOO-lang, it is clear
that the transformations that need to be performed by these plug-ins are the
migration of features that are not literally available in the target language
or platform.

The resulting code model is an AST that can be emitted in the desired language
and conforming to the target platform.

\section{Evaluation}
\label{section:evaluation}

To evaluate the prototype we have chosen to use a system based on the Atmel
ATMEGA1284p micro-controller \cite{datasheet:atmega1284p} and the Digi XBEE S2
Zigbee module \cite{datasheet:xbee}. To drive the hardware a minimalistic
library was used, wrapping the technical calls to the components in more easy
to use functions.

The reason for this at first sight unusual setup is simple: relying on basic
hardware and software allows us to validate that the generator is capable of
generating code even for the most basic environment available. Any step up,
both in hardware or software, would offer better and higher abstractions that
would make it easier to generate code for that situation. It shows that the
requirements of the generator towards the platform are minimal, don't rely on
advanced frameworks or operating systems and can therefore be applied in any
environment, targeting any platform.

For the evaluation we constructed a small WSN consisting of three nodes: an
end-device, a router and a coordinator. The end-device and the router were
completely autonomous nodes, while the coordinator consisted of an XBee module,
directly connected to a computer via a USB break-out board, allowing serial
access via a terminal.

The end-device implements the heartbeat and reputation algorithms and monitors
if the router actually forwards its messages. Next to the IDS logic a
light-sensor is being processed and its readings are forwarded to the
coordinator.

The router is also implemented using both algorithms, to allow both the
end-node and the router to monitor each others' heartbeat. For the router
different implementations were also constructed to allow testing with a fully
cooperating router, a partially failing router and a non-cooperative router.

Two aspects were to be evaluated: functionality and resource usage. On a
functional level, the nodes performed as proposed by the algorithms. Heartbeats
were correctly broadcast and monitored, reputation computations were performed
as expected.

With respect to resource usage, we analyzed the generated source code to
confirm that the generated constructions indeed were better than simple
sequential implementations. At run-time the content of the packets that were
sent showed that where possible multiple messages were aggregated into a single
packet, thus reducing some of the added chattiness caused by the introduction
of the IDS algorithms.

\section{Conclusions and Future Work}
\label{section:conclusions}

WSN nodes typically respond to events in their environment or perform their
tasks at clearly scheduled intervals. Applying a language that has these
concepts at its core, allows focus on the bare essence and reuse of best
practices at the generation level. The rather limited functional domain of WSNs
proofs to be a wonderful candidate for applying code generation techniques.

The ideas proposed in this paper and the prototype are foundations. They show
that code generation techniques can be used to combine different, independent
algorithms in a automated way, while offering better resource usage than simply
sequentially combining the algorithms.

These preliminary steps open up a broad range of possible tracks to explore. On
one hand our goal is to collect as many relevant research papers as possible
and extract the algorithms from them, implementing them using FOO-lang. This
will undoubtedly lead to extensions to the language and its core libraries. On
the code generation front itself, the generator has to be lifted from the
prototype level up to production quality. Next, many optimizations can be added
to it: functional code inlining, continuation-passing style code
structuring,\dots

But on a higher level other challenges are also prominently present: having
formal, platform-independent descriptions of algorithms, allows for simulation
and thorough analysis of their behaviour, both by themselves and in
combinations. Finding ways to combine as many algorithms as possible in a
single generated solution will enable implementers of WSNs to add a decent
level of intrusion detection to their solutions with almost a single click.

Another interesting track is that of policy-based generation and deployment.
Different nodes in the network might benefit from different configurations of
intrusion algorithms. When trying to detect a combination of selective
forwarding and a sinkhole attack \cite{ngai2006intruder}, this algorithm should
only be deployed on coordinators or base stations, not on end-nodes.

Finally we hope that this paper might be received as a call-for-participation
by all IDS in WSNs researchers and will lead to an ever growing collection of
formal descriptions available to those that need them.

\section*{Acknowledgements}
\label{section:acknowledgements}

We would like to thank the reviewers for their thoughtful and helpful comments
that enhanced the readability of this paper. Our gratitude and respect also
goes out to all members of the WSN work group at KU Leuven for creating the
nurturing environment where these ideas could grow.

\bibliographystyle{IEEEtran}
\bibliography{referenties}

\end{document}

